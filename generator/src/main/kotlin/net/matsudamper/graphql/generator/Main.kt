package net.matsudamper.graphql.generator

import com.squareup.kotlinpoet.*
import graphql.parser.ParserOptions
import graphql.schema.*
import graphql.schema.idl.*
import net.matsudamper.graphql.generator.poetbuilder.*
import net.matsudamper.graphql.generator.util.ClassNames
import net.matsudamper.graphql.generator.util.GraphQlToPoetUtil
import net.matsudamper.graphql.generator.util.PackageNames
import net.matsudamper.graphql.generator.util.TypeDefinition
import java.io.File
import java.io.StringReader

internal class Main(
    private val basePackage: String,
    private val schemaFiles: List<File>,
    private val scalarMap: Map<String, String>,
    private val outDir: File
) {
    private val packageNames = PackageNames(
        basePackage = basePackage,
        typePackage = "$basePackage.type",
        queryPackage = "$basePackage.query",
        inputPackage = "$basePackage.input",
        runtimeWiringPackage = "${basePackage}.builder",
        libPackage = "${basePackage}.lib",
        bridgePackage = "${basePackage}.bridge",
        enumPackage = "${basePackage}.enum",
        unionPackage = "${basePackage}.union",
    )

    init {
        ClassNames.basePackage = basePackage
        ClassNames.packageNames = packageNames
    }

    fun generate() {
        val schemaTexts = schemaFiles.map {
            it.readText()
        }
        val graphQLSchema: GraphQLSchema = buildSchema(schemaTexts)
        println("============================introspectionSchemaType")
        println("$graphQLSchema")
        println("query -> ${graphQLSchema.queryType}")
        println("mutation -> ${graphQLSchema.mutationType}")
        val typeDefine = TypeDefinition(
            map = graphQLSchema.typeMap,
            scalarMap = scalarMap,
            packageNames = packageNames
        )

        outDir.deleteRecursively()
        typeDefine.objectType.forEach { (name, value) ->
            val baseType = QlBaseTypeBuilder(
                type = value,
                typeDefine = typeDefine,
            ).build()

            val query = QlQueryBuilder(
                type = value,
                typeDefine = typeDefine,
            ).build()

            val baseObjectType = ClassNames.QlBaseObject.getClassName(name)
            FileSpec.builder(baseObjectType.packageName, baseObjectType.simpleName)
                .addComment("Generated")
                .addType(
                    TypeSpec.objectBuilder(baseObjectType)
                        .addType(baseType.qlBase)
                        .addType(baseType.qlBaseInterface)
                        .addType(query)
                        .build()
                )
                .build()
                .writeTo(outDir)
        }
        typeDefine.unionElements.forEach { (name, value) ->
            UnionBuilder(typeDefine, name, value).build()
                .writeTo(outDir)
        }

        typeDefine.inputType.forEach { (name, value) ->
            InputPoetBuilder(
                typeDefine = typeDefine,
                packageNames = packageNames,
            ).build(name, value, typeDefine)
                .writeTo(outDir)
        }
        typeDefine.enumType.map { (name, value) ->
            GraphQlToPoetUtil.createEnumSpec(name, value, typeDefine)
        }.forEach {
            FileSpec.builder(packageNames.enumPackage, it.name!!)
                .addComment("Generated by ${GraphQlToPoetUtil::class.simpleName}")
                .addType(it)
                .build()
                .writeTo(outDir)
        }

        QueryDefinitionBuilder(
            typeDefine = typeDefine,
            mutationName = graphQLSchema.mutationType?.name,
            queryName = graphQLSchema.queryType?.name,
        ).writeTo(outDir)

        FileSpec.builder(basePackage, "QlSchema")
            .addComment("Generated by ${Main::class.simpleName}")
            .addType(
                TypeSpec.objectBuilder("QlSchema")
                    .addProperty(
                        PropertySpec.builder("text", ClassNames.String)
                            .initializer(
                                CodeBlock.builder().apply {
                                    val doubleQuoteThreeTimes = (0 until 3).joinToString("") { '"'.toString() }
                                    add(
                                        listOf(
                                            doubleQuoteThreeTimes,
                                            schemaTexts.joinToString("\n"),
                                            "${doubleQuoteThreeTimes}.trimIndent()"
                                        ).joinToString("\n")
                                    )
                                }.build()
                            )
                            .build()
                    )
                    .build()
            )
            .build()
            .writeTo(outDir)
    }

    private fun buildSchema(sdl: List<String>): GraphQLSchema {
        val option = ParserOptions.newParserOptions()
            .captureSourceLocation(true)
            .maxTokens(ParserOptions.MAX_QUERY_TOKENS)
            .build()

        val typeRegistry: TypeDefinitionRegistry = SchemaParser().parse(
            StringReader(sdl.first()),
            option,
        ).also { registry ->
            val mergeItems = sdl.drop(1).map {
                SchemaParser().parse(
                    StringReader(it),
                    option,
                )
            }
            mergeItems.map {
                registry.merge(it)
            }
        }

        return SchemaGenerator()
            .makeExecutableSchema(
                typeRegistry,
                RuntimeWiring.newRuntimeWiring()
                    .also { builder ->
                        scalarMap.forEach {
                            builder.scalar(
                                GraphQLScalarType.newScalar()
                                    .name(it.key)
                                    .coercing(DummyCoercing)
                                    .build()
                            )
                        }
                    }
                    .wiringFactory(DummyUnionWiringFactory)
                    .build()
            )
    }

    companion object {
        object DummyCoercing : Coercing<Any, Any> {
            override fun serialize(dataFetcherResult: Any): Any {
                return dataFetcherResult
            }

            override fun parseValue(input: Any): Any {
                return input
            }

            override fun parseLiteral(input: Any): Any {
                return input
            }
        }

        object DummyUnionWiringFactory : WiringFactory {
            override fun providesTypeResolver(environment: UnionWiringEnvironment?): Boolean {
                return true
            }

            override fun getTypeResolver(environment: UnionWiringEnvironment?): TypeResolver {
                return TypeResolver { TODO() }
            }

            override fun providesTypeResolver(environment: InterfaceWiringEnvironment?): Boolean {
                return true
            }

            override fun getTypeResolver(environment: InterfaceWiringEnvironment?): TypeResolver {
                return TypeResolver { TODO() }
            }
        }
    }
}
