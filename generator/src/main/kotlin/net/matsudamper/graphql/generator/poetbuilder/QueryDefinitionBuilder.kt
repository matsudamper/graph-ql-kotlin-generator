package net.matsudamper.graphql.generator.poetbuilder

import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.TypeSpec
import graphql.schema.GraphQLObjectType
import net.matsudamper.graphql.generator.util.ClassNames
import net.matsudamper.graphql.generator.util.GraphQlUtil
import net.matsudamper.graphql.generator.util.KotlinTypeStruct
import net.matsudamper.graphql.generator.util.TypeDefinition
import java.io.File

/**
 * Queryの定義と設定を行うファイルを生成する
 */
internal class QueryDefinitionBuilder(
    private val typeDefine: TypeDefinition,
    private val queryName: String,
    private val mutationName: String,
) {
    fun writeTo(directory: File) {
        val types = typeDefine.objectType.values.toList()

        val queryInfoList = types.map { getInfo(type = it) }

        generateQueryDefinitions(infoList = queryInfoList, directory)

        RuntimeWiringBuilderBuilder(queries = queryInfoList)
            .build()
            .writeTo(directory)
    }

    private fun getInfo(type: GraphQLObjectType): QueryBuilderInfo {
        val queryKotlinName = buildString {
            append("get")
            append(type.name.take(1).toUpperCase())
            append(type.name.drop(1))
        }
        val isMutation = type.name == mutationName
        val isQuery = type.name == queryName
        val fields = GraphQlUtil.getFieldQueryTypes(type).map { fieldType ->
            val fieldKotlinName = buildString {
                append("get")
                append(fieldType.name.take(1).toUpperCase())
                append(fieldType.name.drop(1))
            }

            QueryBuilderInfo.Field(
                fieldName = fieldType.name,
                fieldKotlinName = fieldKotlinName,
            )
        }
        return QueryBuilderInfo(
            kotlinTypeStruct = KotlinTypeStruct.fromGraphQlType(type),
            queryName = type.name,
            queryKotlinName = queryKotlinName,
            fields = fields,
            rootClass = typeDefine.getClassName(type.name),
            isQuery = isQuery,
            isMutation = isMutation,
        )
    }

    /**
     * interface QueryDefinitions {
     *     fun QlReport.Interface.getUser(env: DataFetchingEnvironment): QlUser.Interface
     * }
     */
    private fun generateQueryDefinitions(infoList: List<QueryBuilderInfo>, directory: File) {
        val functions = infoList
            .filter { it.fields.isNotEmpty() }
            .map { info ->
                FunSpec
                    .builder(info.queryKotlinName)
                    .addModifiers(KModifier.ABSTRACT)
                    .apply {
                        if (info.isQuery.not() && info.isMutation.not()) {
                            receiver(typeDefine.getClassName(graphQlQueryName = info.queryName))
                        }
                    }
                    .addParameter(
                        ParameterSpec.builder("env", ClassNames.DataFetchingEnvironment).build()
                    )
                    .returns(ClassNames.QlQuery.getClassName(info.kotlinTypeStruct.getCoreNamedObject().name))
                    .build()
            }


        FileSpec.builder(typeDefine.packageNames.basePackage, ClassNames.QueryDefinitions.getClassNames().simpleName)
            .addComment("Generated by ${QueryDefinitionBuilder::class.simpleName}")
            .addType(
                TypeSpec.interfaceBuilder(ClassNames.QueryDefinitions.getClassNames())
                    .addFunctions(functions)
                    .build()
            )
            .build()
            .writeTo(directory)
    }

    data class QueryBuilderInfo(
        val queryName: String,
        val queryKotlinName: String,
        val rootClass: ClassName,
        val isQuery: Boolean,
        val isMutation: Boolean,
        val fields: List<Field>,
        val kotlinTypeStruct: KotlinTypeStruct,
    ) {
        data class Field(
            val fieldName: String,
            val fieldKotlinName: String,
        )
    }
}
